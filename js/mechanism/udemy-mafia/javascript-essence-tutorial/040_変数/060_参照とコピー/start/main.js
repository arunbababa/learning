// オブジェクトとプリミティブ型

// プリミティブ型→再代入不可（イミュータブル）※letの奴は変数の参照先が変わるだけ、pythonに似ている（いや以下注意だ）

// オブジェクト→変数に参照が格納される、値を変更できるのでミュータブル→名前付きの参照を管理する入れ物と言えるね

// 以下めっちゃ重要多分pythonと全然違う
let a = 1;
let b = a;
b = 100;
// bはaを参照するわけでない、新しい1という値をメモリのどこかに生成しそこを参照するようになる
// んでbを更新的なことすると参照先が変わるだけ、aには影響ない
// これがね確かpythonだと影響あるんだよ

// んでオブジェクトの際めちゃ注意 これはコピーもとに影響を及ぼせる
// まずは以下をしっかりと頭の中に入れよう
// let a = {prop : "Hello"} ←メモリでどうなっているか → 例（→は参照を意味する）, メモリ: 1番地 a → 2番地 {...への参照} → 3番地 {prop} → 4番地 "Hello"
// 2番地注意ねいきなりオブジェクトを参照するわけでない、いきなりプロパティに対応するvalueを取りに行けないのと同じどこかへの参照情報がメモリに格納されるのは自然なこと
// オブジェクトのコピー続行これはねさっきの例でいう2番地の{...}への参照が新しいメモリになるだけでんで実際に参照しに行く3番地には変更ない
// ので以下のようなことをすると大本のvalueも書き変わってしまう
let ob = {prop:"1"}
console.log(ob)
let bb = ob
bb.prop = "w"
console.log(ob)
console.log(bb)

// なお以下のように新しいオブジェクトを再代入する際はもう参照先情報も実際のオブジェクトも変更されるのでよき？
let aaa = {aaa:"aaa"};
let bbb = aaa;
bbb = {};

// まとめ
// プリミティブ型のコピー → 参照先への値がコピーされる（メモリ空間として）
// オブジェクトへのコピー → オブジェクトへの参照がコピーされる